<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Payment Endpoint Test</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üí∞</text></svg>">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
      background-color: #121212;
      color: #ffffff;
    }
    h1 {
      color: #ffffff;
      border-bottom: 1px solid #333;
      padding-bottom: 10px;
    }
    h2 {
      color: #ffffff;
    }
    button {
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 20px 10px 20px 0;
      cursor: pointer;
      border-radius: 4px;
    }
    button:hover {
      background-color: #45a049;
    }
    button:disabled {
      background-color: #cccccc;
      color: #666666;
      cursor: not-allowed;
    }
    #output {
      background-color: #1e1e1e;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 15px;
      min-height: 200px;
      max-height: 500px;
      overflow-y: auto;
      white-space: pre-wrap;
      font-family: monospace;
      color: #ffffff;
    }
    .endpoint-list {
      margin-bottom: 20px;
    }
    .endpoint-list li {
      margin-bottom: 5px;
      font-family: monospace;
      color: #e0e0e0;
    }
    .success {
      color: #4CAF50;
      font-weight: bold;
    }
    .failure {
      color: #f44336;
      font-weight: bold;
    }
    .warning {
      color: #FFA500;
      font-weight: bold;
    }
    code {
      background-color: #2a2a2a;
      padding: 2px 4px;
      border-radius: 4px;
      font-family: monospace;
    }
    pre {
      background-color: #1e1e1e;
      padding: 10px;
      border-radius: 4px;
      color: #e0e0e0;
    }
    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-right: 10px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 20px 0;
    }
    .server-status {
      background-color: #1e1e1e;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 15px;
      margin-top: 10px;
      display: flex;
      align-items: center;
    }
    .status-indicator {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      margin-right: 10px;
    }
    .status-text {
      flex-grow: 1;
    }
    .status-online {
      background-color: #4CAF50;
    }
    .status-offline {
      background-color: #f44336;
    }
    .status-unknown {
      background-color: #FFA500;
    }
  </style>
</head>
<body>
  <h1>Payment Endpoint Test</h1>
  
  <p>This page tests connectivity to your payment backend endpoints. It will try several endpoint URLs and display which ones work.</p>
  
  <div class="server-status">
    <div id="statusIndicator" class="status-indicator status-unknown"></div>
    <div id="statusText" class="status-text">Server status: Checking...</div>
    <button id="checkServer">Check Server</button>
  </div>
  
  <h2>Endpoints to Test</h2>
  <ul class="endpoint-list" id="endpointList">
    <!-- This will be populated by JavaScript -->
  </ul>
  
  <h2>Test Data</h2>
  <p>The following data will be sent to the endpoints:</p>
  <pre id="testData">Loading...</pre>
  
  <div class="toolbar">
    <button id="runTest">Run Payment Test</button>
    <button id="testDocs">Check Docs Endpoint</button>
    <button id="clearResults">Clear Results</button>
  </div>
  
  <h2>Results</h2>
  <div id="output">Click a test button to start testing.</div>
  
  <script>
    // Configuration - adjust these as needed
    const CONFIG = {
      // Backend endpoints to test (in order of preference)
      endpoints: [
        'http://localhost:8000/api/payments/create',
        'http://localhost:8000/api/payments',
        'http://localhost:8000/api/square-test-payment',
        'http://localhost:8000/square-test-payment',
        'http://localhost:8000/payments',
        'http://127.0.0.1:8000/api/payments/create',
        'http://0.0.0.0:8000/api/payments/create'
      ],
      
      // Base URLs to test for server connection
      baseUrls: [
        'http://localhost:8000',
        'http://127.0.0.1:8000',
        'http://0.0.0.0:8000'
      ],
      
      // Test data that simulates a payment form submission
      testPaymentData: {
        sourceId: 'cnon:card-nonce-ok', // Test nonce that works in Square sandbox
        amount: 150,
        idempotencyKey: `test-${Date.now()}`,
        note: 'Test payment from frontend test script',
        referenceId: `test-payment-${Date.now()}`
      },
      
      // Timeout for fetch requests in milliseconds (10 seconds)
      timeout: 10000
    };

    /**
     * Create a fetch request with a timeout
     */
    function fetchWithTimeout(url, options, timeout) {
      return Promise.race([
        fetch(url, options),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error(`Request timed out after ${timeout}ms`)), timeout)
        )
      ]);
    }

    /**
     * Check if the server is reachable
     */
    async function checkServerConnection() {
      console.log('=== Checking Server Connection ===');
      
      const statusIndicator = document.getElementById('statusIndicator');
      const statusText = document.getElementById('statusText');
      
      // Reset status
      statusIndicator.className = 'status-indicator status-unknown';
      statusText.textContent = 'Server status: Checking...';
      
      let isOnline = false;
      let workingUrl = null;
      let responseDetails = '';
      
      // Try each base URL
      for (const baseUrl of CONFIG.baseUrls) {
        console.log(`Checking server at: ${baseUrl}`);
        
        try {
          // Try to get the docs page which should always be available in FastAPI
          const docsUrl = `${baseUrl}/docs`;
          console.log(`Testing docs endpoint at: ${docsUrl}`);
          
          const response = await fetchWithTimeout(docsUrl, {
            method: 'GET',
            headers: {
              'Accept': 'text/html'
            },
            mode: 'cors' // This enables CORS errors to be caught
          }, CONFIG.timeout);
          
          // If we get here, the server responded!
          console.log(`Server responded with status: ${response.status} ${response.statusText}`);
          
          // Get basic info about the response
          const contentType = response.headers.get('content-type') || 'unknown';
          responseDetails = `Status: ${response.status}, Content-Type: ${contentType}`;
          
          if (response.ok) {
            isOnline = true;
            workingUrl = baseUrl;
            break;
          }
        } catch (error) {
          console.warn(`Failed to connect to ${baseUrl}: ${error.message}`);
        }
      }
      
      // Update status indicator
      if (isOnline) {
        statusIndicator.className = 'status-indicator status-online';
        statusText.textContent = `Server status: ONLINE at ${workingUrl} (${responseDetails})`;
      } else {
        statusIndicator.className = 'status-indicator status-offline';
        statusText.textContent = 'Server status: OFFLINE - Make sure your backend server is running';
      }
      
      return { isOnline, baseUrl: workingUrl };
    }

    /**
     * Test the /docs endpoint
     */
    async function testDocsEndpoint() {
      console.log('=== Testing /docs Endpoint ===');
      
      for (const baseUrl of CONFIG.baseUrls) {
        console.log(`Trying docs at: ${baseUrl}/docs`);
        
        try {
          const response = await fetchWithTimeout(`${baseUrl}/docs`, {
            method: 'GET',
            headers: {
              'Accept': 'text/html'
            }
          }, CONFIG.timeout);
          
          console.log(`Response from ${baseUrl}/docs: ${response.status} ${response.statusText}`);
          
          if (response.ok) {
            const text = await response.text();
            console.log(`Received ${text.length} bytes of HTML`);
            console.log(`First 100 chars: ${text.substring(0, 100)}...`);
            return true;
          }
        } catch (error) {
          console.error(`Error accessing ${baseUrl}/docs:`, error.message);
        }
      }
      
      console.error('Could not access /docs on any server URL');
      return false;
    }

    /**
     * Test a single endpoint
     */
    async function testEndpoint(url, data, timeout) {
      console.log(`Testing endpoint: ${url}`);
      
      try {
        // First, check if the endpoint is reachable with an OPTIONS request (preflight)
        try {
          console.log(`Sending OPTIONS preflight to: ${url}`);
          const optionsResponse = await fetchWithTimeout(url, {
            method: 'OPTIONS',
            headers: {
              'Access-Control-Request-Method': 'POST',
              'Access-Control-Request-Headers': 'Content-Type'
            }
          }, timeout);
          
          if (!optionsResponse.ok) {
            console.warn(`‚ùå OPTIONS preflight failed for ${url}: ${optionsResponse.status} ${optionsResponse.statusText}`);
            
            // Log the response headers for debugging
            const headers = {};
            optionsResponse.headers.forEach((value, key) => {
              headers[key] = value;
            });
            console.log('Response headers:', headers);
          } else {
            console.log(`‚úÖ OPTIONS preflight successful for ${url}`);
            
            // Log the CORS headers
            const corsHeaders = {
              'access-control-allow-origin': optionsResponse.headers.get('access-control-allow-origin'),
              'access-control-allow-methods': optionsResponse.headers.get('access-control-allow-methods'),
              'access-control-allow-headers': optionsResponse.headers.get('access-control-allow-headers')
            };
            console.log('CORS headers:', corsHeaders);
          }
        } catch (error) {
          console.warn(`‚ùå OPTIONS preflight error for ${url}: ${error.message}`);
        }
        
        // Now try the actual POST request
        console.log(`Sending POST request to: ${url}`);
        console.log('Request payload:', data);
        
        const response = await fetchWithTimeout(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(data)
        }, timeout);
        
        console.log(`Received response: ${response.status} ${response.statusText}`);
        
        // Log response headers
        const headers = {};
        response.headers.forEach((value, key) => {
          headers[key] = value;
        });
        console.log('Response headers:', headers);
        
        if (!response.ok) {
          // Try to get error details if available
          let errorDetail = await response.text();
          console.log(`Error response body: ${errorDetail}`);
          
          try {
            errorDetail = JSON.parse(errorDetail);
            console.log('Parsed error JSON:', errorDetail);
          } catch (e) {
            // If it's not JSON, keep it as text
            console.log('Response was not valid JSON');
          }
          
          return {
            success: false,
            error: {
              status: response.status,
              statusText: response.statusText,
              detail: errorDetail
            }
          };
        }
        
        // Parse the successful response
        let responseData;
        const contentType = response.headers.get('content-type') || '';
        
        if (contentType.includes('application/json')) {
          responseData = await response.json();
          console.log('Parsed JSON response:', responseData);
        } else {
          const text = await response.text();
          console.log(`Received non-JSON response (${contentType}): ${text}`);
          responseData = { raw: text, _info: "This was a non-JSON response" };
        }
        
        return {
          success: true,
          data: responseData
        };
      } catch (error) {
        console.error(`Unexpected error while testing ${url}:`, error);
        return {
          success: false,
          error: {
            message: error.message,
            stack: error.stack
          }
        };
      }
    }

    /**
     * Test all configured endpoints until one succeeds
     */
    async function testPaymentEndpoint() {
      console.log('=== Starting Payment Endpoint Test ===');
      console.log(`Testing ${CONFIG.endpoints.length} possible endpoints...`);
      
      // First check if server is online
      const serverStatus = await checkServerConnection();
      if (!serverStatus.isOnline) {
        console.error('Backend server appears to be offline. Tests will likely fail.');
      } else {
        console.log(`Backend server is online at ${serverStatus.baseUrl}`);
      }
      
      let successfulEndpoint = null;
      let successResult = null;
      
      // Try each endpoint in turn
      for (const endpoint of CONFIG.endpoints) {
        const result = await testEndpoint(endpoint, CONFIG.testPaymentData, CONFIG.timeout);
        
        if (result.success) {
          console.log(`‚úÖ SUCCESS with endpoint: ${endpoint}`);
          console.log('Response:', result.data);
          successfulEndpoint = endpoint;
          successResult = result;
          break;
        } else {
          console.error(`‚ùå FAILED with endpoint: ${endpoint}`);
          console.error('Error:', result.error);
        }
      }
      
      if (successfulEndpoint) {
        console.log('\n=== Payment Endpoint Test Successful ===');
        console.log(`Working endpoint: ${successfulEndpoint}`);
        console.log('Use this endpoint in your application configuration');
        
        // Return the successful results for further processing if needed
        return {
          endpoint: successfulEndpoint,
          result: successResult
        };
      } else {
        console.error('\n=== Payment Endpoint Test Failed ===');
        console.error('None of the tested endpoints worked.');
        console.error('Please check that:');
        console.error('1. Your backend server is running');
        console.error('2. CORS is properly configured on the backend');
        console.error('3. The payment endpoints are correctly implemented');
        
        return {
          endpoint: null,
          result: null
        };
      }
    }
    
    // Display configuration
    function displayConfig() {
      // Display endpoints
      const endpointList = document.getElementById('endpointList');
      endpointList.innerHTML = '';
      CONFIG.endpoints.forEach(endpoint => {
        const li = document.createElement('li');
        li.textContent = endpoint;
        endpointList.appendChild(li);
      });
      
      // Update test data with new timestamps
      CONFIG.testPaymentData.idempotencyKey = `test-${Date.now()}`;
      CONFIG.testPaymentData.referenceId = `test-payment-${Date.now()}`;
      
      // Display test data
      document.getElementById('testData').textContent = JSON.stringify(CONFIG.testPaymentData, null, 2);
    }
    
    // Custom console logger that outputs to our div
    class DivConsole {
      constructor(outputDiv) {
        this.outputDiv = outputDiv;
        // Store reference to original console methods
        this.originalConsole = {
          log: console.log,
          warn: console.warn,
          error: console.error
        };
      }
      
      log(...args) {
        this.appendToOutput('LOG', args);
        // Use the original console.log, not the overridden one
        this.originalConsole.log(...args);
      }
      
      warn(...args) {
        this.appendToOutput('WARN', args, 'orange');
        // Use the original console.warn, not the overridden one
        this.originalConsole.warn(...args);
      }
      
      error(...args) {
        this.appendToOutput('ERROR', args, 'red');
        // Use the original console.error, not the overridden one
        this.originalConsole.error(...args);
      }
      
      appendToOutput(level, args, color = null) {
        const line = document.createElement('div');
        if (color) {
          line.style.color = color;
        }
        
        // Format the arguments
        let text = args.map(arg => {
          if (typeof arg === 'object') {
            try {
              return JSON.stringify(arg, null, 2);
            } catch (e) {
              return '[Circular Object]';
            }
          }
          return String(arg);
        }).join(' ');
        
        line.textContent = `[${level}] ${text}`;
        this.outputDiv.appendChild(line);
        
        // Auto-scroll to bottom
        this.outputDiv.scrollTop = this.outputDiv.scrollHeight;
      }
    }
    
    // Setup
    document.addEventListener('DOMContentLoaded', () => {
      displayConfig();
      
      const outputDiv = document.getElementById('output');
      const runTestButton = document.getElementById('runTest');
      const testDocsButton = document.getElementById('testDocs');
      const checkServerButton = document.getElementById('checkServer');
      const divConsole = new DivConsole(outputDiv);
      
      // Initial server check
      checkServerConnection();
      
      // Check server button
      checkServerButton.addEventListener('click', async () => {
        outputDiv.innerHTML = '';
        
        // Replace console methods with DivConsole
        const originalLog = console.log;
        const originalWarn = console.warn;
        const originalError = console.error;
        
        console.log = (...args) => divConsole.log(...args);
        console.warn = (...args) => divConsole.warn(...args);
        console.error = (...args) => divConsole.error(...args);
        
        try {
          await checkServerConnection();
        } finally {
          // Restore original console
          console.log = originalLog;
          console.warn = originalWarn;
          console.error = originalError;
        }
      });
      
      // Test docs button
      testDocsButton.addEventListener('click', async () => {
        outputDiv.innerHTML = '';
        testDocsButton.disabled = true;
        
        // Replace console methods with DivConsole
        const originalLog = console.log;
        const originalWarn = console.warn;
        const originalError = console.error;
        
        console.log = (...args) => divConsole.log(...args);
        console.warn = (...args) => divConsole.warn(...args);
        console.error = (...args) => divConsole.error(...args);
        
        try {
          const result = await testDocsEndpoint();
          if (result) {
            outputDiv.innerHTML += '<div class="success">‚úÖ /docs endpoint is accessible!</div>';
          } else {
            outputDiv.innerHTML += '<div class="failure">‚ùå Could not access /docs endpoint on any server!</div>';
          }
        } catch (err) {
          console.error('Test execution error:', err);
        } finally {
          testDocsButton.disabled = false;
          // Restore original console
          console.log = originalLog;
          console.warn = originalWarn;
          console.error = originalError;
        }
      });
      
      // Run test button
      runTestButton.addEventListener('click', async () => {
        // Clear previous results
        outputDiv.innerHTML = '';
        
        // Disable button while test is running
        runTestButton.disabled = true;
        
        // Add loading spinner
        const spinner = document.createElement('span');
        spinner.className = 'spinner';
        const loadingText = document.createElement('span');
        loadingText.textContent = 'Running tests...';
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'warning';
        loadingDiv.appendChild(spinner);
        loadingDiv.appendChild(loadingText);
        outputDiv.appendChild(loadingDiv);
        
        // Replace console methods with DivConsole
        const originalLog = console.log;
        const originalWarn = console.warn;
        const originalError = console.error;
        
        console.log = (...args) => divConsole.log(...args);
        console.warn = (...args) => divConsole.warn(...args);
        console.error = (...args) => divConsole.error(...args);
        
        try {
          // Update test data with new timestamps
          displayConfig();
          
          // Run the test
          const result = await testPaymentEndpoint();
          
          // Remove loading spinner
          loadingDiv.remove();
          
          // Display final result
          if (result.endpoint) {
            const successLine = document.createElement('div');
            successLine.className = 'success';
            successLine.textContent = `‚úÖ SUCCESS: Working endpoint found: ${result.endpoint}`;
            outputDiv.appendChild(successLine);
          } else {
            const failureLine = document.createElement('div');
            failureLine.className = 'failure';
            failureLine.textContent = '‚ùå FAILURE: No working endpoints found!';
            outputDiv.appendChild(failureLine);
          }
        } catch (err) {
          console.error('Test execution error:', err);
        } finally {
          // Re-enable button
          runTestButton.disabled = false;
          
          // Restore original console
          console.log = originalLog;
          console.warn = originalWarn;
          console.error = originalError;
        }
      });
      
      // Clear results button
      document.getElementById('clearResults').addEventListener('click', () => {
        outputDiv.innerHTML = 'Results cleared. Click a test button to start testing.';
      });
    });
  </script>
</body>
</html> 